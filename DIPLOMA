# -*- coding: utf-8 -*-
"""V_FINAL.ДИПЛОМ.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jk5pjI5NAnirisV_qNygFCM88koXuU6Z
"""

# Commented out IPython magic to ensure Python compatibility.
# # Загрузка библиотек
# %%capture
# %pip install TerraYolo
# 
# import os
# import shutil
# import random
# import gdown
# import cv2
# import matplotlib.pyplot as plt
# from PIL import Image
# from TerraYolo.TerraYolo import TerraYoloV5
# import shutil

# Commented out IPython magic to ensure Python compatibility.
# подключение библиотек
# %pip install ultralytics
import ultralytics
ultralytics.checks()

# Загрузка YoloV8
from IPython import display
display.clear_output()

import ultralytics
ultralytics.checks()

#Подключение облачного жесткого диска Google Drive
from google.colab import drive
drive.mount('/content/drive/')

# @title Загрузка...
#archive = /content/drive/MyDrive/DIPLOMA/peoplecount.zip'

# Копирование датасет для обучения модели в рабочую папку
source = '/content/drive/MyDrive/DIPLOMA/peoplecount.zip'

destination = '/content'

shutil.copy(source, destination)

# Задание имени рабочего каталога
DATASET_DIR = '/content/dataset'

# Создание рабочего каталога
os.makedirs(DATASET_DIR, exist_ok=True)
shutil.rmtree('sample_data')

# Распаковка архива
shutil.unpack_archive('/content/peoplecount.zip', DATASET_DIR)
print("Архив успешно разархивирован")

"""# **МОДЕЛЬ НЕЙРОННОЙ СЕТИ YOLO_V5**

# *Формирование датасета*
"""

# Задание пути к yaml-файлу
data_path = os.path.join('/content/dataset/data.yaml') #сохраним путь к файлу в отдельную переменную
with open(data_path, 'r') as f: print(f.read())

# вывод имён файлов из каталогов
img_list = sorted(os.listdir('/content/dataset/train/images'))
lable_list = sorted(os.listdir('/content/dataset/train/labels'))

print(img_list[0])
print(lable_list[0])

# вывод значений из файла разметки объектов на фото
!cat /content/dataset/train/labels/100_jpg.rf.17191796325b6c8f33a8e8f2d2394e82.txt

# @title Вывод случайного изображения из базы


# Выбор случайного изображения
random_image_filename = random.choice(os.listdir(os.path.join(DATASET_DIR,'train/images/')))
image_path = os.path.join(DATASET_DIR, 'train/images/', random_image_filename)

# Получение соответствующего файла с координатами
label_filename = os.path.splitext(random_image_filename)[0] + '.txt'
label_path = os.path.join(DATASET_DIR, 'train/labels/', label_filename)

# Отображение случайного изображения
image = Image.open(image_path)
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.imshow(image)
plt.title("Случайное изображение")
plt.axis('off')

# Отображение изображения с bounding box, если файл с координатами существует
if os.path.exists(label_path):
    with open(label_path, 'r') as label_file:
        lines = label_file.readlines()

    plt.subplot(1, 2, 2)
    plt.imshow(image)
    for line in lines:
        values = line.strip().split()[1:]
        if len(values) == 4:
            x, y, width, height = map(float, values)
            x *= image.width
            y *= image.height
            width *= image.width
            height *= image.height
            rect = plt.Rectangle((x - width / 2, y - height / 2), width, height,
                                 linewidth=2, edgecolor='r', facecolor='none')
            plt.gca().add_patch(rect)


    plt.title("Изображение с Bounding Box")
    plt.axis('off')

else:
    print('Объектов на изображении нет')

plt.show()

"""# Формирование модели нейронной сети TerraYolo (YOLO V5)"""

# определение рабочих папок
print(data_path)
print(DATASET_DIR)

# создание модели нейросети
my_terra_yolov5 = TerraYoloV5(work_dir=DATASET_DIR)

# Вывод структуры модели
my_terra_yolov5.get_annotation('yolov5m')

"""# Обучение"""

# определение параметров обучения нейросети
train_dict=dict()
train_dict['epochs'] = 10
train_dict['data'] = data_path
train_dict['batch'] = 4

# в режиме 'train' происходит запуск обучения с заданными параметрами
my_terra_yolov5.run(train_dict, exp_type='train')

"""# Детекция"""

# Сохраненные веса
!ls /content/dataset/yolov5/runs/train/exp/weights

# путь к лучшей модели (лучшим весам нейросети)
my_terra_yolov5.exp_dict['train']['last_exp_path']+'/weights/best.pt'

# результат работы нейросети на проверочной выборке
TRAIN_DIR = '/content/dataset'

test_dict = dict()
test_dict['source'] = TRAIN_DIR+'/valid/images/'
test_dict['conf'] = 0.55                                     # порог вероятности обнаружения объекта
test_dict['weights'] = my_terra_yolov5.exp_dict['train']['last_exp_path']+'/weights/best.pt' #путь к весам модели

my_terra_yolov5.run(test_dict, exp_type='test')

# вывод результата работы модели нейронной сети
my_terra_yolov5.show_test_images(n_samples=7, img_dir=None) #показать n_samples изображений

"""# Дообучение и статистика"""

# Дообучение YoloV5

train_dict['weights'] = my_terra_yolov5.exp_dict['train'][
                                            'last_exp_path']+'/weights/last.pt' #веса последней эпохи
train_dict['epochs'] = 5
my_terra_yolov5.run(train_dict, exp_type='train') #запуск скрипта train  с параметрами train_dict

# Вывод статистики работы модели нейронной сети YoloV5
val_dict=dict()
val_dict['data'] = train_dict['data']

val_dict['weights'] = os.path.abspath(
        my_terra_yolov5.exp_dict['train']['last_exp_path']+'/weights/best.pt')
my_terra_yolov5.run(val_dict, exp_type='val')

# Вывод графиков по результатам работы модели нейронной сети YoloV5
my_terra_yolov5.show_val_results(img_path=None, img_list=['confusion_matrix.png', 'PR_curve.png'])

# Вывод группы изображений из проверочной выборки
my_terra_yolov5.show_test_images(n_samples=7, img_dir=None) #показать n_samples изображений

"""# Сохранение модели"""

my_drv_path = '/content/drive/MyDrive/' #сохранение путь к диску в переменную

!mkdir {my_drv_path}/yolo_weights/

# сохранение пути в переменную
best_weights_path = my_terra_yolov5.exp_dict['train']['last_exp_path']+'/weights/best.pt'
# и копирование весов
!cp {best_weights_path} {my_drv_path+'/yolo_weights/'}

# чтение названия модели нейронной сети YoloV5
!ls {my_drv_path+'/yolo_weights/'}

# архивирование результатов работы модели нейронной сети YoloV5 на тренировочной выборке
!zip -r archive.zip /content/dataset/yolov5/runs/detect/exp

# архивирование результатов работы модели нейронной сети YoloV5 на проверочной выборке

!zip -r archive.zip /content/dataset/yolov5/runs/val/exp2

"""# **МОДЕЛЬ НЕЙРОННОЙ СЕТИ YOLO_V8**

# Проверка работы необученной модели на тестовом изображении
"""

# параметры видеокарты
!nvidia-smi

# адрес рабочей папки
import os
HOME = os.getcwd()
print(HOME)

# установка YoloV8

!pip install ultralytics==8.0.196

from IPython import display
display.clear_output()

import ultralytics
ultralytics.checks()

# Установка дополнительных библиотек
from ultralytics import YOLO

from IPython.display import display, Image

# Commented out IPython magic to ensure Python compatibility.
# Детекция людей (без определения их пола) на случайном изображении
# %cd {HOME}
!yolo task=detect mode=predict model=yolov8n.pt conf=0.25 source='/content/people-3.jpg' save=True

# Commented out IPython magic to ensure Python compatibility.
# Вывод результата определения (детекции) людей
# %cd {HOME}
Image(filename='/content/runs/detect/predict/people-3.jpg', height=600)

# Описание работы модели на предоставленных данных: количество и типы найденных объектов, скорость работы модели
model = YOLO(f'{HOME}/yolov8n.pt')
results = model.predict(source='/content/people-3.jpg', conf=0.25)

# координаты "bounding box"-ов
results[0].boxes.xyxy

# результат уверенности детекции модели YoloV8
results[0].boxes.conf

"""# Загрузка датасета"""

!pip install ultralytics==8.0.196

# Commented out IPython magic to ensure Python compatibility.
# Загрузка размеченного датасета для обучения YoloV8 с сайта Roboflow.com
!mkdir {HOME}/datasets
# %cd {HOME}/datasets

!pip install roboflow --quiet

from roboflow import Roboflow
rf = Roboflow(api_key="8A2NXtBNYShyr4LE1vks")
project = rf.workspace("iron-man-slzhy").project("diploma_final")
version = project.version(3)
dataset = version.download("yolov8")

"""# Обучение модели YoloV8"""

import shutil

# Укажите путь к исходной папке, которую нужно скопировать
source_folder = '/content/datasets/DIPLOMA_FINAL-3'

# Укажите путь к папке, в которую нужно скопировать содержимое
destination_folder = '/content/datasets/DIPLOMA_FINAL-3/DIPLOMA_FINAL-3'

# Копирование папки
shutil.copytree(source_folder, destination_folder)

# Commented out IPython magic to ensure Python compatibility.
# Обучение модели YoloV8 на тренировочном датасете. 10 эпох
# %cd {HOME}

!yolo task=detect mode=train model=yolov8m.pt data={dataset.location}/data.yaml epochs=10 imgsz=800 plots=True

# описание графиков, произведенных во время обучения модели нейросети
!ls {HOME}/runs/detect/train/

# Commented out IPython magic to ensure Python compatibility.
# вывод гистограммы результата детекции
# %cd {HOME}
Image(filename=f'{HOME}/runs/detect/train9/confusion_matrix.png', width=600)

# Commented out IPython magic to ensure Python compatibility.
# вывод графиков результата работы модели (тренировка, валидация, метрики)
# %cd {HOME}
Image(filename=f'{HOME}/runs/detect/train9/results.png', width=600)

# Commented out IPython magic to ensure Python compatibility.
# вывод изображения по результатам обучения модели
# %cd {HOME}
Image(filename=f'{HOME}/runs/detect/train9/val_batch0_pred.jpg', width=600)

"""# Валидация модели нейросети"""

# Commented out IPython magic to ensure Python compatibility.
# Описание результата валидации обученной нейросети
# %cd {HOME}

!yolo task=detect mode=val model={HOME}/runs/detect/train/weights/best.pt data={dataset.location}/data.yaml

"""# Детекция объектов"""

# Commented out IPython magic to ensure Python compatibility.
# %cd {HOME}
!yolo task=detect mode=predict model={HOME}/runs/detect/train9/weights/best.pt conf=0.25 source=/content/dataset/test/images save=True

import glob
from IPython.display import Image, display

for image_path in glob.glob(f'/content/runs/detect/predict2/260_jpg.rf.5a1e040f07e113d9405ddee7dd404cba.jpg')[:3]:
      display(Image(filename=image_path, width=600))
      print("\n")

# копирование лучших весов обученной модели YoloV8 в папку на облачном диске
source = '/content/runs/detect/train9/weights/best.pt'

destination = '/content/drive/MyDrive/models'

shutil.copy(source, destination)

"""# **ТРЕККИНГ на YOLOV8**"""

# подключение библиотек
!pip install ultralytics==8.2.29
import ultralytics
ultralytics.checks()

# подключение библиотек
!pip install opencv-python
!pip install pillow

# подключение google-диска
from google.colab import drive
drive.mount('/content/drive/')

# копирование обученной модели YoloV8 в рабочую папку
source = '/content/drive/MyDrive/DIPLOMA/Yolo8.pt'

destination = '/content'

shutil.copy(source, destination)

!pip show ultralytics

pip install ultralytics==8.2.29

import cv2
from ultralytics import YOLO
from ultralytics import solutions

# Загрузка предобученной модели нейросети YoloV8
model = YOLO("/content/Yolo8.pt")

# Открытие видеофайла
cap = cv2.VideoCapture("/content/drive/MyDrive/DIPLOMA/test.mp4")
assert cap.isOpened(), "Error reading video file"

# Получение данных о видео: ширина, высота, и количество кадров в секунду (fps)
w, h, fps = (int(cap.get(x)) for x in (cv2.CAP_PROP_FRAME_WIDTH, cv2.CAP_PROP_FRAME_HEIGHT, cv2.CAP_PROP_FPS))

# Определение линии, через которую проходят люди и ведётся их подсчёт
line_points = [(100, 205), (675, 343)]  # Line coordinates

# Определение класса объекта: (0) - man, (1) - woman
classes_to_count = [0, 1]  # Class IDs for person and car

# Инициализация записи видео на выходе из нейросети
video_writer = cv2.VideoWriter("object_counting_output.avi", cv2.VideoWriter_fourcc(*"mp4v"), fps, (w, h))

# Инициализация счётчика объектов с опцией визуализации и другими параметрами
counter = solutions.ObjectCounter(
    view_img=True,  # Показ изображения по ходу процесса
    reg_pts=line_points,  # Регион точек интереса
    classes_names=model.names,  # Имя класса модели YOLO
    draw_tracks=True,  # Рисование линии треккинга объектов
    line_thickness=1,  # Толщина нарисованной линии
)

# Видеопроцессинг кадров через повторение
while cap.isOpened():
    success, im0 = cap.read()
    if not success:
        print("Video frame is empty or video processing has been successfully completed.")
        break

    # Треккинг объектов в текущем кадре, фильтрация через определенные классы
    tracks = model.track(im0, persist=True, show=False, classes=classes_to_count)

    # Применение счётчика объектов в кадре и получение размеченного изображения
    im0 = counter.start_counting(im0, tracks)

    # Запись размеченного кадра в исходящем видео
    video_writer.write(im0)

# Релиз видео и объектов на нём
cap.release()
video_writer.release()

import shutil

# копирование готового видео в папку на диске

source = '/content/object_counting_output.avi'

destination = '/content/drive/MyDrive/DIPLOMA'

shutil.copy(source, destination)

from moviepy.editor import VideoFileClip

# путь к файлу для воспроизведения видео
video_path = "/content/object_counting_output.avi"

# Загрузка видео файла
video = VideoFileClip(video_path)

# Отображение видео
video.ipython_display(width=500, center=False)

"""**НЕЙРОСЕТЬ ОПРЕДЕЛЯЕТ МУЖЧИН И ЖЕНЩИН НА ВИДЕО И ВЕДЁТ ИХ ПОДСЧЁТ ПРИ ПЕРЕСЕЧЕНИИ ЛИНИИ.**

**СПАСИБО ЗА ВНИМАНИЕ!**
"""
